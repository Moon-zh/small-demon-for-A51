********************** DS18B20 **********************
1.DS18B20为单线数字温度计，仅需要一个引脚就可以进行通讯
2.DS18B20的测温范围为-55~+125℃，以0.5℃递增；读出的温度值为9位数字(我们只需要取8位)
3.有报警电路，通过相应的R0M指令可以设置报警温度与监测报警是否触发
4.每一个18b20都有一个唯一的64位的序列号，我们可以用这个来实现用1根管脚控制多个18b20
5.18b20可通过数据线供电(5V)(建议供给5V电源，而不是通过数据线，否则使用时应先保持至少500ms的高电平)

********************** DS18B20相关指令 **********************
18B20共有三种形态的存储器资源，它们分别是：
############################## R0M ##################################
只读存储器，用于存放DS18B20ID编码，其前8位是单线系列编码(DS18B20的编码是19H)，后面48位是芯片唯一的序列号，最后8位是以上56的位的CRC码(冗余校验)。DS18B20共64位ROM

ROM指令共有5条，每一个工作周期只能发一条，ROM指令分别是读ROM数据、指定匹配芯片、跳跃ROM、芯片搜索、报警芯片搜索。ROM指令为8位长度，功能是对片内的64位光刻ROM进行操作。其主要目的是为了分辨一条总线上挂接的多个器件并作处理。

DS28B20芯片ROM指令表：
Read ROM(读ROM)[33H] (方括号中的为16进制的命令字)
这个命令允许总线控制器读到DS18B20的64位ROM。只有当总线上只存在一个DS18B20的时候才可以使用此指令，如果挂接不只一个，当通信时将会发生数据冲突。

Match ROM(指定匹配芯片)[55H]
这个指令后面紧跟着由控制器发出了64位序列号，当总线上有多只DS18B20时，只有与控制发出的序列号相同的芯片才可以做出反应，其它芯片将等待下一次复位。这条指令适应单芯片和多芯片挂接。

Skip ROM(跳跃ROM指令)[CCH]
这条指令使芯片不对ROM编码做出反应，在单总线的情况之下，为了节省时间则可以选用此指令。如果在多芯片挂接时使用此指令将会出现数据冲突，导致错误出现。

Search ROM(搜索芯片)[F0H]
在芯片初始化后，搜索指令允许总线上挂接多芯片时用排除法识别所有器件的64位ROM。
Alarm Search(报警芯片搜索)[ECH]
在多芯片挂接的情况下，报警芯片搜索指令只对附合温度高于TH或小于TL报警条件的芯片做出反应。只要芯片不掉电，报警状态将被保持，直到再一次测得温度什达不到报警条件为止。

############################# RAM ##################################
数据暂存器，用于内部计算和数据存取，数据在掉电后丢失，DS18B20共9个字节RAM，每个字节为8位。   第1、2个字节是温度转换后的数据值信息，第3、4个字节是用户EEPROM(常用于温度报警值储存)的镜像。在上电复位时其值将被刷新。第5个字节则是用户第3个EEPROM的镜像。第6、7、8个字节为计数寄存器，是为了让用户得到更高的温度分辨率而设计的，同样也是内部温度转换、计算的暂存单元。第9个字节为前8个字节的CRC码。

在ROM指令发送给18B20之后，紧接着(不间断)就是发送存储器操作指令了。操作指令同样为8位，共6条，存储器操作指令分别是写RAM数据、读RAM数据、将RAM数据复制到EEPROM、温度转换、将EEPROM中的报警值复制到RAM、工作方式切换。

DS28B20芯片存储器操作指令表：
Write Scratchpad (向RAM中写数据)[4EH]
这是向RAM中写入数据的指令，随后写入的两个字节的数据将会被存到地址2(报警RAM之TH)和地址3(报警RAM之TL)。写入过程中可以用复位信号中止写入。

Read Scratchpad (从RAM中读数据)[BEH]
此指令将从RAM中读数据，读地址从地址0开始，一直可以读到地址9，完成整个RAM数据的读出。芯片允许在读过程中用复位信号中止读取，即可以不读后面不需要的字节以减少读取时间。

Copy Scratchpad (将RAM数据复制到EEPROM中)[48H]
此指令将RAM中的数据存入EEPROM中，以使数据掉电不丢失。此后由于芯片忙于EEPROM储存处理，当控制器发一个读时间隙时，总线上输出“0”，当储存工作完成时，总线将输出“1”。在寄生工作方式时必须在发出此指令后立刻超用强上拉并至少保持10MS，来维持芯片工作。

Convert T(温度转换)[44H]
收到此指令后芯片将进行一次温度转换，将转换的温度值放入RAM的第1、2地址。此后由于芯片忙于温度转换处理，当控制器发一个读时间隙时，总线上输出“0”，当储存工作完成时，总线将输出“1”。在寄生工作方式时必须在发出此指令后立刻超用强上拉并至少保持500MS，来维持芯片工作。

Recall EEPROM(将EEPROM中的报警值复制到RAM)[B8H]
此指令将EEPROM中的报警值复制到RAM中的第3、4个字节里。由于芯片忙于复制处理，当控制器发一个读时间隙时，总线上输出“0”，当储存工作完成时，总线将输出“1”。另外，此指令将在芯片上电复位时将被自动执行。这样RAM中的两个报警字节位将始终为EEPROM中数据的镜像。

Read Power Supply(工作方式切换)[B4H]
此指令发出后发出读时间隙，芯片会返回它的电源状态字，“0”为寄生电源状态，“1”为外部电源状态。
############################# EEPROM ##################################
非易失性记忆体，用于存放长期需要保存的数据，上下限温度报警值和校验数据，DS18B20共3位EEPROM，并在RAM都存在镜像，以方便用户操作。


********************** DS18B20 读写**********************
1.18b20的写数据。通过给管脚送8位数据指令来控制18b20将要执行的功能或序列号的匹配
2.18b20的读数据。通过之前给18b20写入相关的数据指令，接下来接收8位的相关数据，不同的指令接收的数据量也不定，通常由多个8位数据组成
3.18b20的读或是写，都要首先初始化，然后匹配或跳过序列号，之后进行读写

********************** DS18B20时序 **********************
################### 初始化时序 ###################
CS18B20:CLR	DS18B20		//18b20置0		
	MOV	R0,#240		//延时280微秒
	DJNZ	R0,$
	SETB	DS18B20		//18b20置1
	MOV	R0,#30		//延时60微秒
	DJNZ	R0,$
	JNB	DS18B20,$	//等待18b20置1
	MOV	R0,#250		//延时500微秒
	DJNZ	R0,$
	RET
################### 写入时序 ###################
E18B20:	MOV	B,#08H		//写入8位	
E1:	CLR	DS18B20		//18b20置0
	RRC	A		//A右移位到C
	MOV	DS18B20,C	//将C值给18b20
	MOV	R0,#28		//延时56微秒
	DJNZ	R0,$
	SETB	DS18B20		//18b20置1(送完1位)
	DJNZ	B,E1		//循环
	RET			
################### 读出时序 ###################
RD18B20:MOV	B,#08H		//读出8位		
RD1:	CLR	DS18B20		//18b20置0
	MOV	R0,#1		//延时2微秒
	DJNZ	R0,$
	SETB	DS18B20		//18b20置1
	MOV	C,DS18B20	//18b20值给C
	RRC	A		//将C值移至A
	MOV	R0,#23		//延时46微秒
	DJNZ	R0,$
	DJNZ	B,RD1		//循环
	RET			//(A值为读出8位数值)

********************** DS18B20数据转换 **********************
带有温度读取与温度转换的子程序：
WDZH:	JNB	DS18B20,OUT	//温度读取，看18b20是否忙
	LCALL	BI1		//18b20初始化并跳过读序列号
	MOV	A,#44H		//发送温度转换指令
	LCALL	E18B20
	LCALL	BI1		//18b20初始化并跳过读序列号
	MOV	A,#0BEH		//发送读取温度指令
	LCALL	E18B20
	LCALL	RD18B20		//发送读数据指令
	MOV	B,A		//读出整数部分的十位与小数位
	SWAP	A		//高低位交换
	ANL	A,#0FH		//屏蔽低位
	MOV	WD2,A		//十位存中间单元
	MOV	A,B
	ANL	A,#0FH		//保留小数位
	MOV	DPTR,#TAB1	//由于18b20本身小数位并不精确，所以采用人工精确数值
	MOVC	A,@A+DPTR
	MOV	WD1,A		//小数位存中间单元
	LCALL	RD18B20		//发送读指令(读出整数个位与温度正负)
	SWAP	A		//高低位交换
	ADD	A,WD2		//十位与个位相加
	MOV	WD2,A		//最终的整数部分完成
OUT:	RET

BI1:	LCALL	CS18B20		//18b20初始化
	MOV	A,#0CCH		//跳过读序列码
	LCALL	E18B20
	RET

注：若18b20不工作在低温环境下可以屏蔽正负的判断
############################################
带匹配序列码的温度读取与温度转换子程序：
WDZH:	JNB	DS18B20,OUT	//温度读取，看18b20是否忙
	LCALL	BI2		//选中要控制的18b20
	MOV	A,#44H		//发送温度转换指令
	LCALL	E18B20
	LCALL	BI2		//选中要读取的18b20
	MOV	A,#0BEH		//发送读取温度指令
	LCALL	E18B20
	LCALL	RD18B20		//发送读数据指令
	MOV	B,A		//读出整数部分的十位与小数位
	SWAP	A		//高低位交换
	ANL	A,#0FH		//屏蔽低位
	MOV	WD2,A		//十位存中间单元
	MOV	A,B
	ANL	A,#0FH		//保留小数位
	MOV	DPTR,#TAB1	//由于18b20本身小数位并不精确，所以采用人工精确数值
	MOVC	A,@A+DPTR
	MOV	WD1,A		//小数位存中间单元
	LCALL	RD18B20		//发送读指令(读出整数个位与温度正负)
	SWAP	A		//高低位交换
	ADD	A,WD2		//十位与个位相加
	MOV	WD2,A		//最终的整数部分完成
OUT:	RET

BI2:	LCALL	CS18B20		//18b20初始化
	MOV	A,#055H		//发送匹配序列号指令
	LCALL	E18B20
	LCALL	PPCX		//匹配序列码
	RET
################### 序列号匹配时序 ###################
PPCX:	LCALL	CS18B20		//18B20初始化
	MOV	A,#55H		//发送匹配指令
	LCALL	E18B20
	PUSH	DPH		//保护DPTR
	PUSH	DPL
PP1:	CLR	A		//清A
	MOVC	A,@A+DPTR	//从表中取出序列号
	CJNE	A,#0FFH,PP0	//判断序列号是否全部发送完毕
	AJMP	PPC		//发送完毕则结束
PP0:	LCALL	E18B20		//发送序列号
	INC	DPTR		//+DPTR
	AJMP	PP1		//循环

PPC:	POP	DPL		//释放DPTR
	POP	DPH
	RET			//结束

注：需建立表格，表格内存储8位16进制序列号，最后加1个0ffh(结束码) 调用此程序前应首先给DPTR赋好相应序列号表格 如：
	MOV	DPTR,#TW1
	LCALL	PPCX
	RET

或：	MOV	DPTR,#TW1
	LCALL	WDZH
	RET

TW1:	DB	28H,66H,9FH,90H,02H,00,00H,19H,0FFH

################### 序列号读取时序 ###################
XLH	LCALL	CS18B20	//18b20 初始化
	MOV	A,#33H	//读序列号命令
	LCALL	E18B20
	MOV	R1,#30H	//间接寻址存储序列号
	MOV	R7,#8	//64位序列号需循环8次
XL1:	LCALL	RD18B20	//读8位
	PUSH	ACC	//保护A
	ANL	A,#0F0H	//屏蔽高位(读取8位序列号中高四位)
	SWAP	A	//高低位交换
	MOV	@R1,A	//存入显示单元
	INC	R1	//选择下一个单元
	POP	ACC	//释放A
	ANL	A,#0F0H	//屏蔽高位(读取8位序列号中低四位)
	MOV	@R1,A	//存入显示单元
	INC	R1	//选择下一个单元
       	DJNZ	R7,M2	//循环
	RET

注：由于是64位则需要16个显示单元(一次读8位，读8次，一次为两位序列码，故显示单元为8*2=16个  序列码是先读低位再读高位，匹配时也应先写入低位)

********************** DS18B20注 **********************
1.ds18b20序列号读取时只能使用单线，且只能挂1个18b20

2.本文档所写时序几乎已为最简时序，修改时序极有可能造成不能正常工作

3.使用多个18b20时还是建议一个I/O口使用1个，特殊条件只能用1个口时，应先写一个读序列号的程序将18b20序列号一个一个读出来，做好标注，然后根据已知序列号再写目标程序